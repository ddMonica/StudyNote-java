# 面向对象

面向对象程序设计的第一步，就是在问题领域中识别出有效的对象，然后从识别出的对象中抽象出类来。

## 一、面向对象概述

面向对象是一种符合人类思维习惯的编程思想。现实生活中存在各种形态不同的事物，这些事物之间存在着各种各样的联系。在程序中使用对象来映射现实中的事物，使用对象的关系来描述事物之间的联系，这种思想就是面向对象。

**与面向过程的区别**：

![image-20211010090033193](C:\Users\丁银钿\AppData\Roaming\Typora\typora-user-images\image-20211010090033193.png)

**面向对象的的特点：**

![image-20211010090204855](C:\Users\丁银钿\AppData\Roaming\Typora\typora-user-images\image-20211010090204855.png)





## 二、Java中的类和对象

### 1、类与对象的关系

**说明：**面向对象的编程思想，力图让程序中对事物的描述与该事物在现实中的形态保持一致。为了做到这一点，面向对象的思想中提出了两个概念——类和对象。
**抽象概念：**类是对某一类事物的抽象描述，而对象用于表示现实中该类事物的个体。



![image-20211010092241959](C:\Users\丁银钿\AppData\Roaming\Typora\typora-user-images\image-20211010092241959.png)

**分析：**可以将上图人看作是一个类，将每个具体的人（如小韩、小石等）看作对象，从人与具体个人之间的关系便可以看出类与对象之间的关系。

**类用于描述多个对象的共同特征，它是对象的模板，而对象用于描述现实中的个体，它是类的实例。对象是类的具体化，并且一个类可以对应多个对象**

### 2、类的定义

- 在面向对象的思想中，最核心的就是对象。
- 为了在程序中创建对象，首先需要定义一个类。
- 类是对象的抽象，它用于描述一组对象的共同特征和行为，例如人都有姓名、年龄、性别等特征，还有学习、工作、购物等行为。
- 以面向对象的编程思想，就可以将某一类中共同的特征和行为封装起来，把共同特征作为类的属性（也叫成员变量），把共同行为作为类的方法（也叫成员方法）。

#### 2.1 类的格式定义

![image-20211010093828604](C:\Users\丁银钿\AppData\Roaming\Typora\typora-user-images\image-20211010093828604.png)

#### 2.2 成员变量![image-20211010093912631](C:\Users\丁银钿\AppData\Roaming\Typora\typora-user-images\image-20211010093912631.png)

#### 2.3 成员方法

![image-20211010094039980](C:\Users\丁银钿\AppData\Roaming\Typora\typora-user-images\image-20211010094039980.png)

**注意：**

在Java中，定义在类中的变量被称为成员变量，定义在方法中的变量被称为局部变量。如果在某一个方法中定义的局部变量与成员变量同名，这种情况是允许的，此时方法中通过变量名访问到的是局部变量，而并非成员变量。

```java
public class Person{
    int age = 10;
    void speak(){
        int age = 30;
        System.out.println("我今年"+age+"岁了");
}
```

**分析：**上面的代码中，speak()方法中所访问的变量age，就是局部变量，也就是说，当有另外一个程序来调用speak()方法时，输出的值为30，而不是10。

### 3、对象的创建与使用

#### 3.1 对象创建的语法格式

```java
类名 对象名 = new 类名（）;
```

#### 3.2 对象创建的使用方法

```java
Person p = new Peson();
```

#### 3.3 对象创建的内存分配

在创建对象时，程序会占用两块内存区域，分别是栈内存和堆内存。其中Person类型的变量p被存放在栈内存中，它是一个引用，会指向真正的对象；通过new Person()创建的对象则放在堆内存中，这才是真正的对象。

![image-20211010095553776](C:\Users\丁银钿\AppData\Roaming\Typora\typora-user-images\image-20211010095553776.png)

**注意：**

Java将内存分为两种，即栈内存和堆内存。其中栈内存用于存放基本类型的变量和对象的引用变量（如Person p），堆内存用于存放由new创建的对象和数组。

#### 3.4 对象成员的调用

1. 通过对象的引用来访问对象所有的成员。

   ```java
   对象引用.对象成员
   ```

2. 直接使用创建的对象本身来引用对象成员

   ```Java
   new 类名（）.对象成员
   ```

   **注意：**第2种方式，创建实例对象的同时就访问了对象成员，并且在创建后只能访问其中某一个成员，而不能像第1种方式那样可以访问多个对象成员。同时，由于没有对象引用的存在，在完成某一个对象成员的访问后，该对象就会变成垃圾对象。所以，在实际开发中，创建实例对象时多数会使用对象引用。

#### 3.5 成员变量的初始值

![image-20211010100630725](C:\Users\丁银钿\AppData\Roaming\Typora\typora-user-images\image-20211010100630725.png)

#### 3.6 垃圾对象的形成

当没有任何变量引用对象时，该对象将成为垃圾对象，不能再被使用。

1. 对象的引用超出作用域

   ```java
   {
       Person p1 = new Person();
       ...
   }
   ```

   **说明：**变量p1引用了一个Person类型的对象，当这段代码运行完毕时，变量p1就会超出其作用域而被销毁，这时Person类型的对象将因为没有被任何变量所引用而变成垃圾。

2. 对象的引用重新指向空地址（null）。

   ```java
   {
       Person p2 =new Person();
       ...
       p2=null;
       ...
   }
   ```

   **说明：**使用变量p2引用了一个Person类型的对象，接着将变量p2的值置为null，被p2所引用的Person对象就会失去引用，成为垃圾对象。

3. 对象被重新创建

4. 引用所在的方法执行结束

### 4、访问控制符

在Java中，针对类、成员方法和属性提供了四种访问级别，分别是private、default、protected和public。![image-20211010101309588](C:\Users\丁银钿\AppData\Roaming\Typora\typora-user-images\image-20211010101309588.png)

**四种访问控制级别说明：**

- private（当前类访问级别）：如果类的成员被private访问控制符来修饰，则这个成员<u>只能被该类的其他成员访问</u>，其他类无法直接访问。类的良好封装就是通过private关键字来实现的。
- default（包访问级别）：如果一个类或者类的成员不使用任何访问控制符修饰，则称它为默认访问控制级别，这个类或者类的成员只能被<u>本包</u>中的其他类访问。
- protected（子类访问级别）：如果一个类的成员被protected访问控制符修饰，那么这个成员<u>既能被同一包下的其他类访问，也能被不同包下该类的子类访问。</u>
- public（公共访问级别）：这是一个最宽松的访问控制级别，如果一个类或者类的成员被public访问控制符修饰，那么这个类或者类的成员能被所有的类访问，不管访问类与被访问类是否在同一个包中。

![image-20211010101428517](C:\Users\丁银钿\AppData\Roaming\Typora\typora-user-images\image-20211010101428517.png)



## 三、类的封装

### 1、为什么需要封装

```java
public static void main(String[]args){
    Person p = new Person();
    p.name = "张三";
    p.age = -18;
    p.speak();
}
```

**示例分析：**上述示例将年龄赋值为一个负数-18，在语法上不会有任何问题，因此程序可以正常运行，但在现实生活中明显是不合理的。
**解决方案：**为了避免出现上述不合理的问题，在设计一个Java类时，应该对成员变量的访问作出一些限定，不允许外界随意访问，这就需要实现类的封装。

### 2、如何实现封装

**定义**：类的封装，是指将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象的内部信息，而是通过该类所提供的方法来实现对内部信息的操作访问。
**如何实现封装：**在定义一个类时，将类中的属性私有化，即使用private关键字来修饰，私有属性只能在它所在类中被访问，如果外界想要访问私有属性，需要提供一些使用public修饰的公有方法，其中包括用于获取属性值的getXxx()方法和设置属性值的setXxx()方法。

```java
class Person(){
    private String name;
    private int age;
    public String getName(){
        return name;
    }
    public void setName(String name){
        this.name =name;
    }
    public int getAge(){
        return age;
    }
    public void getAge(int age){
        if(age<=0){
            System.out.println("您输入的不正确")
        }else{
            this.age =age; 
        }
    }
    public void speak(){
        System.out.println("我叫"+name+"我今年"+age+"岁了!")
    }
}

public class Example{
    public static void main (String[]args){
        Person p = new Person();
        p.setNma("张三");
        p.setAge(18);
        p.speak();
    }
}
```



## 四、方法的重载和递归

### 1、方法的重载

**假设如下场景**：要在程序中实现一个对数字求和的方法。
**可能的办法**：由于参与求和数字的个数和类型都不确定，因此要针对不同的情况去设计不同的方法（这样的话非常麻烦，也不便于命名和区分）。
**解决办法**：Java允许在一个程序中定义多个名称相同，但是参数的类型或个数不同的方法，这就是方法的重载。

### 2、方法的递归

**定义：**方法的递归是指在一个方法的内部调用自身的过程。递归必须要有结束条件，不然就会陷入无限递归的状态，永远无法结束调用。

## 五、构造方法

实例化一个类的对象后，如果要为这个对象中的属性赋值，则必须通过直接访问对象的属性或调用setXxx()方法的方式才可以。如果需要在实例化对象的同时就为这个对象的属性进行赋值，可以通过构造方法来实现。

**定义：**构造方法（也被称为构造器）是类的一个特殊成员，它会在类实例化对象时被自动调用。

### 1、构造方法的定义

**定义构造方法的语法格式：**

```java
[修饰符]方法名（[参数列表]）{
	方法体
}
```

为了方便实例化对象，构造方法通常会使用public来修饰。

**定义构造方法时需同时满足以下三个条件：**

1. 方法名与类名相同。
2. 在方法名的前面没有返回值类型的声明。
3. 在方法中不能使用return语句返回一个值，但是可以单独写return语句来作为方法的结束。

### 2、构造方法的重载

**定义：**与普通方法一样，构造方法也可以重载，在一个类中可以定义多个构造方法，只要每个构造方法的参数类型或参数个数不同即可。
**说明：**在创建对象时，可以通过调用不同的构造方法来为不同的属性进行赋值。

**注意：**在Java中的每个类都至少有一个构造方法，如果在一个类中没有显示地定义构造方法，系统会自动为这个类创建一个默认的无参构造方法。可以定义多个构造方法，按照参数的不同去调用。如果定义了有参的构造方法，最好再定义一个无参的构造方法。

## 六、this关键字

### 1、为什么使用this关键字

在文件3-9中使用变量表示年龄时，构造方法中使用的参数是a，成员变量使用的是age，虽然在语法上没有任何问题，但这样的程序可读性很差。这时可以将Person类中表示年龄的变量进行统一命名，例如都声明为age，但是这样做又会导致<u>成员变量和局部变量</u><u>的名称冲突</u>，在方法中将无法访问成员变量age。

**解决方案：**为了解决这个问题，Java中提供了一个关键字this来指代当前对象，用于在方法中访问对象的其他成员。

### 2、this关键字的三种常见用法

1. 通过this关键字调用<u>成员变量</u>，解决与局部变量名称冲突问题。

   ```java
   class Person{
       int age;
       public Person(int age){
           this.age = age;
       }
   }
   ```

   

2. 通过this关键字调用<u>成员方法</u>。

   ```java
   class Person{
       public void openMounth(){
           
       }
       public void speak(){
           this.openMounth();//this可以省略
       }
   }
   ```

   

3. 通过this关键字调用<u>构造方法</u>。（调用构造方法时用this关键字）

   ```java
   class Person{
       public Person(){
           System.out.println("无参的构造方法")
       }
       public Person(int age){
           this();
           System.out.println("有参的构造方法")
       }
       
   }
   ```

   **注意：**

   1. 只能在构造方法中使用this调用其他的构造方法，不能在成员方法中使用。
   2. 在构造方法中，使用this调用构造方法的语句必须是该方法的第一条执行语句，且只能出现一次。
   3. 不能在一个类的两个构造方法中使用this互相调用。

## 七、static关键字

Java中的static关键字，用于修饰类的成员，如成员变量、成员方法以及代码块等，被static修饰的成员具备一些特殊性。比如**被static关键字修饰的成员变量、方法可以被类直接访问，而不需要预先构造类的实例化对象**。

### 1、静态变量

- 在一个Java类中，可以使用static关键字来修饰成员变量，该变量被称作静态变量。
- 静态变量被所有实例共享，可以使用“类名.变量名”的形式来访问。
- static关键字只能用于修饰成员变量，不能用于修饰局部变量，否则编译会报错。

**内存分配：**

从图可以看出，所有学生对象共享一个名称为schoolName的变量。在一个Java类中，要实现这种功能可以使用static关键字来修饰成员变量，该变量被称作静态变量，它可以被所有实例所共享。

![image-20211010114400794](C:\Users\丁银钿\AppData\Roaming\Typora\typora-user-images\image-20211010114400794.png)

**注意：**static关键字只能用于修饰成员变量，不能用于修饰局部变量，否则编译会报错。

### 2、静态方法

- 被static关键字修饰的方法称为静态方法。
- 同静态变量一样，静态方法可以使用“类名.方法名”的方式来访问，也可以通过类的实例对象来访问。
- 在一个静态方法中只能访问用static修饰的成员，原因是没有被static修饰的成员需要先创建对象才能访问，而静态方法在被调用时可以不创建任何对象。

### 3、静态代码块

- 在Java中，使用一对大括号包围起来的若干行代码被称为一个代码块。
- 使用static关键字修饰的代码块称为静态代码块。
  当类被加载时，静态代码块会执行，并且只会执行一次。
- 在程序中，经常使用静态代码块来对类的成员变量进行初始化。

## 八、类的继承

### 1、继承的概念

在现实生活中，说到继承，多会想到子女继承父辈的财产、事业等。在程序中，继承描述的是事物之间的所属关系，通过继承可以使多种事物之间形成一种关联体系。

**定义：**在Java中，<u>类的继承是指在一个现有类的基础上去构建一个新的类</u>，构建出来的新类被称作<u>子类</u>，现有类被称作<u>父类或基类</u>，子类会自动拥有父类所有可继承的属性和方法。

**类继承的语法格式extends：**

```java
[修饰符] class 子类名 extends 父类名{
    //程序核心代码
} 
```

**注意：**

- 在Java中，类只支持单继承，不允许多重继承，也就是说一个类只能有一个直接父类。
- 在Java中，多个类可以继承同一个父类。
- 在Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类。
- 在Java中，子类和父类是一种相对概念，也就是说，一个类是某个类父类的同时，也可以是另一个类的子类。

### 2、重写父类的方法

**定义：**在继承关系中，子类会自动继承父类中公共的方法，但有时在子类中需要对继承的方法进行一些修改，即对父类的方法进行重写。

**注意：**

- 子类中重写的方法需要和父类被重写的方法具有相同的**方法名**、**参数列表**以及**返回值类型**。
- 子类重写父类方法时，不能使用比父类中被重写的方法更严格的访问权限。

### 3、super关键字

**问题：**在继承关系中，当子类重写父类的方法后，子类对象将无法直接访问父类被重写的方法。

**解决方法：**<u>在Java中专门提供了一个super关键字来访问父类的成员</u>，例如访问父类的成员变量、成员方法和构造方法。

**具体使用：**

1. 使用super关键字调用父类的成员变量和成员方法。

   ```java
   super.成员变量
   super.成员方法
   ```

2. 使用super关键字调用父类的构造方法。

   ```java
   super([参数1，参数2...])
   ```

**注意：**

1. 通过super调用父类构造方法的代码必须位于子类构造方法的第一行，并且只能出现一次，否则代码在编译的过程中会报错

2. 在子类的构造方法中一定会调用父类的某一个构造方法。这时可以在子类的构造方法中通过super关键字指定调用父类的哪一个构造方法，如果没有指定，那么在实例化对象时，会默认调用父类无参的构造方法

   所以当定义了有参的构造方法后，尽量在类里面再显式地定义一个无参构造方法，这样可以避免该类在继承时出现错误。

### 4、Object类

在Java中提供了一个Object类，它是所有类的父类，即每个类都直接或间接继承自该类。
Object类通常被称之为超类、基类或根类。
当定义一个类时，如果没有使用extends关键字为这个类显示地指定父类，那么该类会默认继承Object类。

**常用方法：**

![image-20211010160011752](C:\Users\丁银钿\AppData\Roaming\Typora\typora-user-images\image-20211010160011752.png)

**Object中的toString()方法：**

![image-20211010160254989](C:\Users\丁银钿\AppData\Roaming\Typora\typora-user-images\image-20211010160254989.png)

在实际开发中通常希望toString()方法返回的不仅仅是对象的基本信息，而是一些特有的信息，为此可以通过重写Object的toString()方法来实现。

## 九、final关键字

final关键字可用于修饰类、变量和方法，它有“不可更改”或者“最终”的含义。因此被final修饰的类、变量和方法将具有以下特性。

1. final修饰的类不能被继承
2. final修饰的方法不能被子类重写
3. final修饰的变量（成员变量和局部变量）是常量，只能被赋值一次

### 1、final关键字修饰类

### 2、final关键字修饰方法

### 3、final关键字修饰变量

## 十、抽象类和接口

### 1、抽象类

**问题：**例如前面在定义Animal类时，shout()方法用于表示动物的叫声，但是不同的动物，叫声也是不同的，因此在shout()方法中无法准确描述动物的叫声。如何能使Animal类中既包含shout()方法，又无需提供其方法的实现呢？

**解决方法：**Java提供了抽象方法来满足这种需求。抽象方法必须使用abstract关键字来修饰，并且在定义方法时不需要实现方法体。当一个类中包含了抽象方法，那么该类也必须使用abstract关键字来修饰，这种使用abstract关键字修饰的类就是抽象类。

**抽象类及抽象方法定义的语法格式：**

```java
//定义抽象类
[修饰符] abstract class 类名{
    //定义抽象方法
    [修饰符] abstract 方法返回值类型 方法名([参数列		表]);
    //其他方法或属性
}
```

**注意：**包含抽象方法的类必须定义为抽象类，但抽象类中可以不包含任何抽象方法。另外，**抽象类是不可以被实例化**的，如果想调用抽象类中定义的抽象方法，需要创建一个子类，在子类中实现抽象类中的抽象方法

### 2、接口

![image-20211010162647807](C:\Users\丁银钿\AppData\Roaming\Typora\typora-user-images\image-20211010162647807.png)

**JDK 8接口定义的语法格式：**

```java
    [修饰符] interface 接口名 [extends 父接口1,父接口2,...] {
          [public] [static] [final] 常量类型 常量名 = 常量值;
          [public] [abstract] 方法返回值类型 方法名([参数列表]);
          [public] default 方法返回值类型 方法名([参数列表]){
	// 默认方法的方法体
          }
          [public] static 方法返回值类型 方法名([参数列表]){
	// 类方法的方法体
          }
    }

```

- 修饰符可以使用public或直接省略（省略时默认采用包权限访问控制符）。
- 在接口内部可以定义多个常量和抽象方法，定义常量时必须进行初始化赋值，定义默认方法和静态方法时，可以有方法体。
- 在接口中定义常量时，可以省略“public static final”修饰符，接口会默认为常量添加“public static final”修饰符。与此类似，在接口中定义抽象方法时，也可以省略“public abstract”修饰符，定义default默认方法和static静态方法时，可以省略“public”修饰符，这些修饰符系统都会默认进行添加。

1. 接口中可以包含三类方法，抽象方法、默认方法、静态方法。
2. **静态方法**可以通过**“接口名.方法名”**的形式来调用。
3. **抽象方法**和**默认方法**只能**通过接口实现类的实例对象来调用**。
4. **接口的实现类，必须实现接口中的所有抽象方法。**

```java
 [修饰符] class 类名 [extends 父类名] [implements 接口1,接口2,...] {
          ...
    }

```

**特点总结：**

1. 从JDK 8开始，接口中的方法除了包含抽象方法外，还包含默认方法和静态方法，默认方法和静态方法都可以有方法体，并且静态方法可以直接通过“接口.方法名”来调用。
2. **当一个类实现接口时，如果这个类是抽象类，只需实现接口中的部分抽象方法即可，否则需要实现接口中的所有抽象方法。**
3. 一个类可以通过implements关键字同时实现多个接口，被实现的多个接口之间要用英文逗号（,）隔开。
4. 接口之间可以通过extends关键字实现继承，并且一个接口可以同时继承多个接口，接口之间用英文逗号（,）隔开。
5. 一个类在继承一个类的同时还可以实现接口，此时，extends关键字必须位于implements关键字之前。

## 十一、多态

### 1、多态概述

**定义：**在Java中，多态是指不同类的对象在调用同一个方法时所呈现出的多种不同行为。
**说明：**通常来说，在一个类中定义的属性和方法被其他类继承或重写后，当把子类对象直接赋值给父类引用变量时，相同引用类型的变量调用同一个方法所呈现出的多种不同形态。
**作用：**通过多态，消除了类之间的耦合关系，大大提高了程序的可扩展性和可维护性。

**注意：**Java的多态性是由**类的继承**、**方法重写**以及**父类引用指向子类对象**体现的。由于一个父类可以有多个子类，多个子类都可以重写父类方法，并且多个不同的子类对象也可以指向同一个父类。这样，程序只有在运行时程序才能知道具体代表的是哪个子类对象，这就体现了多态性。

### 2、对象的类型转换

**向上转型：**在多态的学习中，涉及到将子类对象当做父类类型使用的情况，此种情况在Java的语言环境中称为“向上转型”。

```java
 Animal an1 = new Cat();     // 将Cat类对象当做Animal类型来使用
    Animal an2 = new Dog();    // 将Dog类对象当做Animal类型来使用

```

**注意：**将子类对象当做父类使用时不需要任何显式地声明，需要注意的是，此时不能通过父类变量去调用子类特有的方法。

**类型判断：**Java提供了一个关键字instanceof，它可以判断一个对象是否为某个类（或接口）的实例或者子类实例。

```java
 对象（或者对象引用变量） instanceof 类（或接口）

```



## 十二、内部类

在Java中，允许在一个类的内部定义类，这样的类称作内部类，这个内部类所在的类称作外部类。

### 1、成员内部类

**定义**：在一个类中除了可以定义成员变量、成员方法，还可以定义类，这样的类被称作成员内部类。
**说明：**在成员内部类中，可以访问外部类的所有成员，包括成员变量和成员方法；在外部类中，同样可以访问成员内部类的变量和方法。
**创建内部类对象的具体语法格式如下：**

```java
    外部类名.内部类名 变量名 = new 外部类名().new 内部类名(); 

```



### 2、局部内部类

**定义：**局部内部类，也叫做方法内部类，就是定义在某个局部范围中的类，它和局部变量一样，都是在方法中定义的，其有效范围只限于方法内部。
**说明：**在局部内部类中，局部内部类可以访问外部类的所有成员变量和方法，而局部内部类中的变量和方法却只能在创建该局部内部类的方法中进行访问。

### 3、静态内部类

**定义：**所谓静态内部类，就是使用static关键字修饰的成员内部类。
**说明：**静态内部类在成员内部类前增加了static关键字，在功能上，静态内部类中只能访问外部类的静态成员，同时通过外部类访问静态内部类成员时，可以跳过外部类从而直接通过内部类访问静态内部类成员。
**创建静态内部类对象的具体语法格式如下：**

```java
外部类名.静态内部类名 变量名 = new 外部类名.静态内部类名();

```



### 4、匿名内部类

**定义：**匿名内部类其实就是没有名称的内部类。
**说明：**在调用包含有接口类型参数的方法时，通常为了简化代码，可以直接通过匿名内部类的形式传入一个接口类型参数，在匿名内部类中直接完成方法的实现。

**注意：**从JDK 8开始，允许在局部内部类、匿名内部类中访问非final修饰的局部变量，而在JDK 8之前，局部变量前必须加final修饰符，否则程序编译报错。

**创建匿名内部类对象的具体语法格式如下：**

```java
new 父接口(){
        // 匿名内部类实现部分
    }

```



## 十三、JDK 8--Lambda表达式

Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。

### 1、lambda表达式入门

匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。

解决方法：可以使用JDK 8中新增的Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。

### 2、航叔式接口

### 3、方法引用与构造器引用

## 十四、异常

### 1、什么是异常

1. **生活中的异常：**例如感冒发烧，工作时电脑蓝屏、死机等。
2. **程序中的异常：**在程序运行的过程中，也会发生这种非正常状况，例如程序运行时磁盘空间不足、网络连接中断、被加载的类不存在等。
3. **程序异常解决方法：**针对程序中的非正常情况，Java语言中引入了异常，以异常类的形式对这些非正常情况进行封装，并通过异常处理机制对程序运行时发生的各种问题进行处理。

![image-20211012134836087](C:\Users\丁银钿\AppData\Roaming\Typora\typora-user-images\image-20211012134836087.png)

**Throwable类的常用方法：**

![image-20211012135339131](C:\Users\丁银钿\AppData\Roaming\Typora\typora-user-images\image-20211012135339131.png)

### 2、异常的类型

![image-20211012141236579](C:\Users\丁银钿\AppData\Roaming\Typora\typora-user-images\image-20211012141236579.png)

**1、编译时的异常**

异常类汇总：在Exception的子类中，除了RuntimeException类及其子类外，其他子类都是编译时异常。

特点：编译时异常的特点是在程序编写过程中，Java编译器就会对编写的代码进行检查，如果出现比较明显的异常就必须对异常进行处理，否则程序无法通过编译。

处理编译时异常的方式如下：

![image-20211012141420551](C:\Users\丁银钿\AppData\Roaming\Typora\typora-user-images\image-20211012141420551.png)

**2、运行时异常**

异常汇总：RuntimeException类及其子类都是运行时异常。

特点：运行时异常是在程序运行时由Java虚拟机自动进行捕获处理的，即使没有使用try..catch语句捕获或使用throws关键字声明抛出，程序也能编译通过，只是在运行过程中可能报错。

Java中常见的运行时异常如下：

![image-20211012141524375](C:\Users\丁银钿\AppData\Roaming\Typora\typora-user-images\image-20211012141524375.png)

运行时异常错误分析：运行时异常一般是由于程序中的逻辑错误引起的，在程序运行时无法恢复。

![image-20211012141602794](C:\Users\丁银钿\AppData\Roaming\Typora\typora-user-images\image-20211012141602794.png)

### 3、try...catch和finally

当程序发生异常时，会立即终止，无法继续向下执行。为了保证程序能够有效的执行，Java中提供了一种对异常进行处理的方式——异常捕获。

![image-20211012141627546](C:\Users\丁银钿\AppData\Roaming\Typora\typora-user-images\image-20211012141627546.png)

**注意：**在try{}代码块中，发生异常语句后面的代码是不会被执行的。在程序中，如果希望有些语句无论程序是否发生异常都要执行，这时就可以在try…catch语句后，加一个finally{}代码块。

![image-20211012141718907](C:\Users\丁银钿\AppData\Roaming\Typora\typora-user-images\image-20211012141718907.png)



### 4、throws关键字

一般在程序开发中，开发者通常会意识到程序可能出现的问题，可以直接通过try...catch对异常进行捕获处理。但有些时候，方法中代码是否会出现异常，开发者并不明确或者并不急于处理，为此，Java允许将这种异常从当前方法中抛出，然后让后续的调用者在使用时再进行异常处理。 

![image-20211012141758618](C:\Users\丁银钿\AppData\Roaming\Typora\typora-user-images\image-20211012141758618.png)

**注意：**当调用者在调用有抛出异常的方法时，除了可以在调用程序中直接进行try…catch异常处理外，也可以根据提示使用throws关键字继续将异常抛出，这样程序也能编译通过。但是，程序发生了异常，终究是需要进行处理的，如果没有被处理，程序就会非正常终止。

### 5、throw关键字

![image-20211012142015670](C:\Users\丁银钿\AppData\Roaming\Typora\typora-user-images\image-20211012142015670.png)

**说明：**通过throw关键字抛出异常后，还需要使用throws关键字或try…catch对异常进行处理。
**注意：**如果throw抛出的是Error、RuntimeException或它们的子类异常对象，则无需使用throws关键字或try…catch对异常进行处理。

![image-20211012142052231](C:\Users\丁银钿\AppData\Roaming\Typora\typora-user-images\image-20211012142052231.png)

### 6、自定义异常

Java中定义了大量的异常类，虽然这些异常类可以描述编程时出现的大部分异常情况，但是在程序开发中有时可能需要描述程序中特有的异常情况，例如在设计divide()方法时不允许被除数为负数

解决方法：Java允许用户自定义异常，但自定义的异常类必须继承自Exception或其子类。

![image-20211012142125073](C:\Users\丁银钿\AppData\Roaming\Typora\typora-user-images\image-20211012142125073.png)

## 十五、垃圾回购

- 在Java中，当一个对象成为垃圾后仍会占用内存空间，时间一长，就会导致内存空间的不足。
- 针对内存空间不足的情况，Java中引入了垃圾回收机制（Java GC）。
- 有了垃圾回收机制，程序员不需要过多关心垃圾对象回收的问题，Java虚拟机会自动回收垃圾对象所占用的内存空间。

**对象在内存中的状态转换：**

![image-20211012142243707](C:\Users\丁银钿\AppData\Roaming\Typora\typora-user-images\image-20211012142243707.png)

一个对象在彻底失去引用成为垃圾后会暂时地保留在内存中，当这样的垃圾堆积到一定程度时，Java虚拟机就会启动垃圾回收器将这些垃圾对象从内存中释放，从而使程序获得更多可用的内存空间。

**注意：**虽然通过程序可以控制一个对象何时不再被任何引用变量所引用，但是却无法精确的控制Java垃圾回收的时机。
**回收方式：**除了等待Java虚拟机进行自动垃圾回收外，还可以通知系统垃圾回收器进行垃圾回收。

![image-20211012142320985](C:\Users\丁银钿\AppData\Roaming\Typora\typora-user-images\image-20211012142320985.png)

**说明：**以上两种方式可以通知启动垃圾回收器进行垃圾回收，但是否立即进行垃圾回收依然具有不确定性。多数情况下，执行后总是有一定的效果。

1. 当一个对象在内存中被释放时，它的finalize()方法会被自动调用，finalize()方法是定义在Object类中的实例方法。
2. 任何Java类都可以重写Object类的finalize()方法，在该方法中清理该对象占用的资源。如果程序终止之前仍然没有进行垃圾回收，则不会调用失去引用对象的finalize()方法来清理资源
3. 只有当程序认为需要更多的额外内存时，垃圾回收器才会自动进行垃圾回收。